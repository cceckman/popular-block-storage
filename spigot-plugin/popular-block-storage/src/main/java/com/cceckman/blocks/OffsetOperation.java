package com.cceckman.blocks;

import java.util.logging.Logger;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.BlockState;
import org.bukkit.block.data.type.Chest;
import org.bukkit.event.HandlerList;
import org.bukkit.inventory.ItemStack;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.Vector;

// Runnable operation of updating or reading from a block storage device.
// Generated by a server thread; closes over a World.
// Per: https://www.spigotmc.org/wiki/using-the-event-api/
public class OffsetOperation extends BukkitRunnable {
    public OffsetOperation(
        final Logger l, 
        final Location origin, 
        final boolean write,
        final long offset, 
        final byte[] buffer) {
        logger_ = l;
        origin_ = origin;
        write_ = write;
        offset_ = offset;
        buffer_ = buffer;
    }

    private static final HandlerList HANDLERS = new HandlerList();

    public HandlerList getHandlers() {
        return HANDLERS;
    }

    public static HandlerList getHandlerList() {
        return HANDLERS;
    }

    // Context fields.
    private final Location origin_;
    private final Logger logger_;

    // Semantic fields: r/w, offset & buffer (which implies length.)
    private final boolean write_;
    private final long offset_; // Offset of the request: first address read / written.
    private final byte[] buffer_;

    // Data is organized hierarchically:
    // - Along the Z-axis by slice (4096 KiB)
    // - Along the Y-axis by row (4 per slice --> 1024 bytes)
    // - Along the X-axis by column (19 per row)
    // - Within a chest by byte index (54 per row)

    static final int kBytesPerSlice = 4096;
    // Slice is the XY-slice that the given offset is in.
    private static int slice(final long offset) {
        return (int)(offset / kBytesPerSlice);
    }

    // Vertical (Y-axis) rows in a a slice.
    static final int kRowsPerSlice = 4;
    private static int row(final long offset) {
        final int slice_offset = (int)(offset % kBytesPerSlice);
        final int chest_index = slice_offset / kSlotsPerChest;
        return chest_index % kRowsPerSlice;
    }

    // Slots in a (small) Minecraft chest. We use one slot per byte.
    // TODO(cceckman): Use large chests (54 slots)
    static final int kSlotsPerChest = 27;
    private static int slot(final long offset) {
        return (int)(offset % kSlotsPerChest);
    }

    // We can derive the column index from the other constants.
    private static int column(final long offset) {
        final int slice_offset = (int)(offset % kBytesPerSlice); // [0, 4096)
        final int chest_index = slice_offset / kSlotsPerChest;
        return chest_index / kRowsPerSlice;
    }

    private void ensureChest(Block block) {
        Location partnerLocation = block.getLocation().clone().add(new Vector(1, 0, 0));
        BlockState partner = partnerLocation.getBlock().getState();
        BlockState state = block.getState();

        // If either is not a chest, we're in repair mode.
        if(state.getType() != Material.CHEST || partner.getType() != Material.CHEST) {
            state.setType(Material.CHEST);
            partner.setType(Material.CHEST);
        }

        // Set all the object data except contents.
        Chest dataLeft = (Chest)state.getBlockData();
        Chest dataRight = (Chest)partner.getBlockData();
        dataLeft.setType(Chest.Type.LEFT);
        dataRight.setType(Chest.Type.RIGHT);
        dataLeft.setFacing(BlockFace.NORTH);
        dataRight.setFacing(BlockFace.NORTH);

        partner.update(true);
        state.update(true);

        logger_.info(String.format("Turned (%d, %d, %d) into a chest",
            block.getX(), block.getY(), block.getZ()));
    }

    private Location location(final long offset) {
        int z = slice(offset) * 2;      // Space out slices by 1 block (deep).
        int y = row(offset_) * 2;       // Space out rows by 1 block (high). Chest has to open!
        int x = column(offset_) * 3;    // Space out columns by 2 blocks; chest is 2 wide.
        return origin_.clone().add(new Vector(x,y,z));
    }

    // Applies this transformation to the world.
    // Must be applied from the main thread!
    public void run() {
        logger_.info(String.format("Received write request for @%d (%d bytes)", offset_, buffer_.length));
        var world = origin_.getWorld();

        Block block = world.getBlockAt(location(offset_));
        ensureChest(block);
        org.bukkit.block.Chest state = (org.bukkit.block.Chest)block.getState();
        var inv = state.getSnapshotInventory();

        for(int i = 0; i < buffer_.length; i++) {
            final var offset =  this.offset_ + i;
            final var slot = slot(offset);

            if(slot == 0) {
                // We've rolled over into a new block.
                // Apply existing state, by force
                if(write_) {
                    state.update(true);
                }
                // And ensure the next block is a chest.
                block = world.getBlockAt(location(offset));
                ensureChest(block);
                // Yes, there's a race here between turning it into a chest and getting the state.
                // No, we won't worry about it.
                state = (org.bukkit.block.Chest)block.getState();
                inv = state.getSnapshotInventory();
            }

            // Place the byte in the chest, OR read into buffer.
            if(write_) {
                inv.setItem(slot, from(buffer_[i]));
            } else {
                buffer_[i] = to(inv.getItem(slot));
            }
        }

        if(write_) {
            // One last commit.
            state.update(true);
        }
    }

    private static ItemStack from(byte b) {
        // TODO: Actual mapping
        return new ItemStack(Material.CHEST);
    }

    private static byte to(ItemStack s) {
        // TODO: Actual mapping
        return (byte)0xff;
    }
}